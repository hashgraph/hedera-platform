/*
 * (c) 2016-2021 Swirlds, Inc.
 *
 * This software is owned by Swirlds, Inc., which retains title to the software. This software is protected by various
 * intellectual property laws throughout the world, including copyright and patent laws. This software is licensed and
 * not sold. You must use this software only in accordance with the terms of the Hashgraph Open Review license at
 *
 * https://github.com/hashgraph/swirlds-open-review/raw/master/LICENSE.md
 *
 * SWIRLDS MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THIS SOFTWARE, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * OR NON-INFRINGEMENT.
 */
package com.swirlds.platform;

import com.swirlds.common.CommonUtils;
import com.swirlds.common.crypto.CryptographyException;
import com.swirlds.common.crypto.internal.CryptographySettings;
import com.swirlds.common.internal.CryptoUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLServerSocketFactory;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManagerFactory;
import javax.security.auth.x500.X500Principal;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.InvalidKeyException;
import java.security.KeyManagementException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.Signature;
import java.security.SignatureException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.function.Consumer;

import static com.swirlds.logging.LogMarker.CERTIFICATES;
import static com.swirlds.logging.LogMarker.EVENT_SIG;
import static com.swirlds.logging.LogMarker.EXCEPTION;

/**
 * An instantiation of this class holds all the keys and CSPRNG state for one Platform object. It also
 * performs signature creation/verification, data encryption/decryption, and TLS connection key agreement,
 * using 3 separate key pairs (with names starting sig, enc, agree). No other class should store any secret
 * or private key/seed information. No other class (other than user apps) should ever create a Socket or
 * ServerSocket or SSLSocket or SSLServerSocket. No other class should perform cryptographic operations.
 * <p>
 * The algorithms and key sizes used here are chosen in accordance with the IAD-NSA Commercial National
 * Security Algorithm (CNSA) Suite, and TLS 1.2, as implemented by the SUN and SunEC security providers,
 * using the JCE Unlimited Strength Jurisdiction files. The TLS suite used here is called
 * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384. Java uses the NIST p-384 curve specified by the CNSA for ECDH
 * and ECDSA.
 * <p>
 * To aid in key recovery, this is designed so that all of the keys here are generated by deterministic
 * functions of a triplet (master key, swirld ID, member ID), which are passed in to the constructor. When
 * TLS key agreement needs a source of random numbers, it uses SecureRandom with "SHA1PRNG", which calls the
 * underlying operating system's /dev/random and /dev/urandom (or Windows equivalent) to incorporate entropy
 * gathered by the operating system. So the key pairs are generated deterministically, but key agreement
 * uses true random numbers.
 * <p>
 * At the time this class is first being written, neither TLS 1.3 nor Java 9 are available. As they become
 * available, it may become appropriate to switch from ECDSA/ECDHE to something based on Ed25519, for
 * increased speed, decreased bandwidth usage, and better safety (e.g., not needing strong random numbers
 * for key agreement). But when (or whether) that change happens will depend on whether standards such as
 * the CNSA Suite are updated. In the longer term, this may be upgraded to a post quantum algorithm (or a
 * hybrid using both pre-quantum and post-quantum). But again, this will depend on a number of factors. The
 * plan is to continue to follow the national standard (currently CNSA Suit), changing the algorithms as the
 * standard changes.
 *
 * @deprecated Since 0.7.0
 */
@Deprecated
public class Crypto extends CryptoUtils {
	// This class is designed to generate all a user's keys from their master key, to help with
	// key recovery if their computer is erased.
	//
	// We follow the "CNSA Suite" (Commercial National Security Algorithm), which is the current US
	// government standard for protecting information up to and including Top Secret:
	//
	// https://www.iad.gov/iad/library/ia-guidance/ia-solutions-for-classified/algorithm-guidance/commercial-national
	// -security-algorithm-suite-factsheet.cfm
	//
	// The CNSA standard specifies AES-256, SHA-384, RSA, ECDH and ECDSA. So that is what is used here.
	// Their
	// intent appears to be that AES and SHA will each have 128 bits of post-quantum security, against
	// Grover's and the BHT algorithm, respectively. Of course, ECDH and ECDSA aren't post-quantum, but
	// AES-256 and SHA-384 are (as far as we know).

	// keystore settings
	protected final static String KEYSTORE_TYPE = "pkcs12";
	// number of bytes in a hash
	final public static int HASH_SIZE_BYTES = 48; // 384 bits (= 3*128)
	// size (in bits) of a public or private key
	final static int SIG_KEY_SIZE_BITS = Settings.useRSA ? 3072 : 384;
	final static int ENC_KEY_SIZE_BITS = 384; // 3*128 bits
	final static int AGR_KEY_SIZE_BITS = 384; // 3*128 bits
	// max number of bytes in a signature
	// this might be as high as 16+2*ceiling(KEY_SIZE_BITS/8), but is 8 less than that here
	final static int SIG_SIZE_BYTES = Settings.useRSA ? 384 : 104; // 832 bits (= 2*384/8+16-8)
	// size of each symmetric key, in bytes
	final static int SYM_KEY_SIZE_BYTES = 32; // 256 bits

	// the algorithms and providers to use (AGR is key agreement, ENC is encryption, SIG is signatures)
	final static String AGR_TYPE = "EC";
	final static String AGR_PROVIDER = "SunEC";

	final static String ENC_TYPE = "EC";
	final static String ENC_PROVIDER = "SunEC";

	final static String SIG_TYPE1 = Settings.useRSA  //
			? "RSA" // or RSA or SHA384withRSA
			: "EC"; // or EC or SHA384withECDSA
	final static String SIG_PROVIDER = Settings.useRSA //
			? "SunRsaSign" //
			: "SunEC";
	final static String SIG_TYPE2 = Settings.useRSA  //
			? "SHA384withRSA" // or RSA or SHA384withRSA
			: "SHA384withECDSA"; // or EC or SHA384withECDSA

	final static String[] TLS_SUITES = { "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384" };// this is the only TLS protocol we
	// will allow

	// certificate settings
	final static Date DEFAULT_VALID_FROM = Date
			.from(Instant.parse("2000-01-01T00:00:00Z"));
	final static Date DEFAULT_VALID_TO = Date
			.from(Instant.parse("2100-01-01T00:00:00Z"));

	// SSL settings
	protected final static String KEY_MANAGER_FACTORY_TYPE = "SunX509";// recommended by FIPS
	protected final static String TRUST_MANAGER_FACTORY_TYPE = "SunX509";// recommended by FIPS
	protected final static String SSL_VERSION = "TLSv1.2";

	////////////////////////////////////////////////////////////////////

	static {
		// add provider only if it's not in the JVM
		if (Security
				.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
			Security.addProvider(new BouncyCastleProvider());
		}
	}

	/** a pool of threads used to verify signatures and generate keys, in parallel */
	private ExecutorService cryptoThreadPool;

	/** nondeterministic CSPRNG */
	private static SecureRandom nonDetRandom = null;

	/** use this for all logging, as controlled by the optional data/log4j2.xml file */
	private static final Logger log = LogManager.getLogger();

	// public and private keys, certs, trust stores for signing and encryption and key agreement
	private KeyPair sigKeyPair = null; // used for signing
	private KeyPair agrKeyPair = null; // used for key agreement
	private KeyPair encKeyPair = null; // used for encrypting
	private X509Certificate sigCert = null; // each cert is a certificate made from a key pair
	private X509Certificate agrCert = null;
	private X509Certificate encCert = null;
	private KeyStore sigTrustStore = null; // each trust store holds all the certs of one kind (sig/agr/enc)
	private KeyStore agrTrustStore = null;
	private KeyStore encTrustStore = null;
	private KeyStore agrKeyStore = null; // holds agrKeyPair.getPrivate() with chain {agrCert}

	// used to create and receive TLS connections, based on the given trustStore
	KeyManagerFactory keyManagerFactory;
	TrustManagerFactory trustManagerFactory;
	SSLContext sslContext;
	SSLServerSocketFactory sslServerSocketFactory;
	SSLSocketFactory sslSocketFactory;

	/**
	 * Prepare this Crypto object to create and receive TLS connections. This is done using the trustStore
	 * whose reference was passed in to the Crypto constructor. That trustStore must contain certs for all
	 * the members before calling prepSockets. This method will then create the appropriate
	 * KeyManagerFactory, TrustManagerFactory, SSLContext, SSLServerSocketFactory, and SSLSocketFactory, so
	 * that it can later create the TLS sockets. This should only be called after the trustStore that was
	 * passed to the Crypto constructor has had all of its certs added to it.
	 */
	void prepSocketsSSL() {
		if (!Settings.useTLS) {
			return;
		}

		try {
			char[] password = getKeystorePassword();
			// the agrKeyStore should contain an entry with both agrKeyPair.getPrivate() and agrCert
			// PKCS12 uses file extension .p12 or .pfx
			agrKeyStore = KeyStore.getInstance(KEYSTORE_TYPE);
			agrKeyStore.load(null, null); // initialize
			agrKeyStore.setKeyEntry("key", agrKeyPair.getPrivate(), password,
					new Certificate[] { agrCert });

			// "PKIX" may be more interoperable than KeyManagerFactory.getDefaultAlgorithm or
			// TrustManagerFactory.getDefaultAlgorithm(), which was "SunX509" on one system tested
			keyManagerFactory = KeyManagerFactory
					.getInstance(KEY_MANAGER_FACTORY_TYPE);
			keyManagerFactory.init(agrKeyStore, password);
			trustManagerFactory = TrustManagerFactory
					.getInstance(TRUST_MANAGER_FACTORY_TYPE);
			trustManagerFactory.init(sigTrustStore);
			sslContext = SSLContext.getInstance(SSL_VERSION);
			SSLContext.setDefault(sslContext);
			sslContext.init(keyManagerFactory.getKeyManagers(),
					trustManagerFactory.getTrustManagers(), getNonDetRandom());
			sslServerSocketFactory = sslContext.getServerSocketFactory();
			sslSocketFactory = sslContext.getSocketFactory();
		} catch (NoSuchAlgorithmException | UnrecoverableKeyException
				| KeyStoreException | KeyManagementException
				| CertificateException | IOException e) {
			log.error(EXCEPTION.getMarker(), "", e);
		}
	}

	/**
	 * Print to the console some info about what is in the given key store or trust store..
	 *
	 * @param heading
	 * 		a string to print at the start of each line
	 * @param keyStore
	 * 		the key store or trust store to print
	 */
	void printStore(String heading, KeyStore keyStore) {
		try {
			CommonUtils.tellUserConsole(heading + "size: " + keyStore.size());
		} catch (Exception e) {
			CommonUtils.tellUserConsole(ExceptionUtils.getStackTrace(e));
			CommonUtils.tellUserConsole(e.toString());
		}
	}

	/**
	 * Return the public key used for verifying signatures by this member.
	 *
	 * @return the public key
	 */
	public PublicKey getSigPublicKey() {
		return sigKeyPair.getPublic();
	}

	/**
	 * Return the public key used for encrypting data to be read by this member.
	 *
	 * @return the public key
	 */
	public PublicKey getEncPublicKey() {
		return encKeyPair.getPublic();
	}

	/**
	 * Return the public key used when this member negotiates an ephemeral session key for a TLS connection.
	 *
	 * @return the public key
	 */
	public PublicKey getAgrPublicKey() {
		return agrKeyPair.getPublic();
	}

	/**
	 * Create a new Socket, then connect to the given ip and port.
	 * <p>
	 * Security.newClientSocketConnect and Security.newServerSocketConnect are the only places in this
	 * program where new sockets are created.
	 *
	 * @param ipAddress
	 * 		the ip address to connect to
	 * @param port
	 * 		the port to connect to
	 * @return the new socket, or null if it was unable to connect
	 * @throws IOException
	 * 		if the connection cannot be made
	 */
	Socket newClientSocketConnect(String ipAddress, int port)
			throws IOException {
		Socket clientSocket;
		if (Settings.useTLS) {
			clientSocket = sslSocketFactory.createSocket();
			// ensure the connection is ALWAYS the exact cipher suite we've chosen
			((SSLSocket) clientSocket).setEnabledCipherSuites(TLS_SUITES);
			((SSLSocket) clientSocket).setWantClientAuth(true);
			((SSLSocket) clientSocket).setNeedClientAuth(true);
		} else {
			clientSocket = new Socket();
		}

		if (0 <= Settings.socketIpTos && Settings.socketIpTos <= 255) {
			// set the IP_TOS option
			jdk.net.Sockets.setOption(clientSocket,
					java.net.StandardSocketOptions.IP_TOS,
					Settings.socketIpTos);
		}

		// clientSocket.setReuseAddress(true); //can delete. No effect unless multicast
		clientSocket.setSoTimeout(Settings.timeoutSyncClientSocket);
		clientSocket.setTcpNoDelay(Settings.tcpNoDelay);
		//do NOT do clientSocket.setSendBufferSize or clientSocket.setReceiveBufferSize
		//because it causes a major bug in certain situations
		clientSocket.connect(new InetSocketAddress(ipAddress, port),
				Settings.timeoutSyncClientConnect);
		if (Settings.useTLS) {
			((SSLSocket) clientSocket).startHandshake();
		}
		return clientSocket;
	}

	/**
	 * Create a new ServerSocket, then connect to the given ip and port.
	 * <p>
	 * Crypto.newClientSocketConnect and Crypto.newServerSocketConnect are the only places in this program
	 * where new sockets are created.
	 *
	 * @param ipAddress
	 * 		the ip address to connect to
	 * @param port
	 * 		the port to connect to
	 * @return the new socket, or null if it was unable to connect
	 * @throws IOException
	 * 		if the connection cannot be made
	 */
	ServerSocket newServerSocketConnect(byte[] ipAddress, int port)
			throws IOException {
		ServerSocket serverSocket;
		if (Settings.useTLS) {
			serverSocket = sslServerSocketFactory.createServerSocket();
			((SSLServerSocket) serverSocket).setEnabledCipherSuites(TLS_SUITES);
			((SSLServerSocket) serverSocket).setWantClientAuth(true);
			((SSLServerSocket) serverSocket).setNeedClientAuth(true);
		} else {
			serverSocket = new ServerSocket();
		}
		if (0 <= Settings.socketIpTos && Settings.socketIpTos <= 255) {
			// set the IP_TOS option
			jdk.net.Sockets.setOption(serverSocket,
					java.net.StandardSocketOptions.IP_TOS,
					Settings.socketIpTos);
		}
		InetSocketAddress endpoint = new InetSocketAddress(
				InetAddress.getByAddress(ipAddress), port);
		serverSocket.bind(endpoint); // try to grab a port on this computer
		serverSocket.setReuseAddress(true);
		//do NOT do clientSocket.setSendBufferSize or clientSocket.setReceiveBufferSize
		//because it causes a major bug in certain situations

		// not doing serverSocket.setSoTimeout(...) here because the caller will set it appropriately.
		return serverSocket;
	}

	/**
	 * Return the nondeterministic secure random number generator stored in this Crypto instance. If it
	 * doesn't already exist, create it.
	 *
	 * @return the stored SecureRandom object
	 */
	private SecureRandom getNonDetRandom() {
		// synchronize to protect the static variable nonDetRandom
		if (nonDetRandom == null) { // a shared (static) nondeterministic CSPRNG
			try {
				nonDetRandom = SecureRandom.getInstanceStrong();
			} catch (NoSuchAlgorithmException e) {
				log.error(EXCEPTION.getMarker(), "", e);
				throw new CryptographyException(e, EXCEPTION);
			}
			// call nextBytes before setSeed, because some algorithms (like SHA1PRNG) become
			// deterministic if you don't. This call might hang if the OS has too little entropy
			// collected. Or it might be that nextBytes doesn't hang but getSeed does. The behavior is
			// different for different choices of OS, Java version, and JDK library implementation.
			nonDetRandom.nextBytes(new byte[1]);
		}
		return nonDetRandom;
	}

	/**
	 * This constructor creates a Crypto object holding all the keys and certificates. If createKeys is
	 * true, this also generates the key pairs and certs and CSPRNG state. The key pairs are generated as a
	 * function of the seed. The seed is the combination of the three parameters. The signing key pair is
	 * used to sign all 3 certs. If createKeys is false, then it doesn't create any keys or certificates,
	 * and it doesn't add anything to the trust stores. It just reads its own key pairs from keyStore, and
	 * remembers the trust stores.
	 *
	 * @param selfId
	 * 		the ID of the member running this Crypto object and its associated Platform object
	 * @param name
	 * 		The name to associate with the key. For example, if it is "alice", then the three key
	 * 		pairs will be named "s-alice", "e-alice", "a-alice" for signing, encrypting, and key
	 * 		agreement.
	 * @param masterKey
	 * 		master key used to derive key pairs for many identities in many swirlds
	 * @param swirldId
	 * 		which swirlds is running
	 * @param memberId
	 * 		which identity is acting as a member in this swirld (because one human user might
	 * 		have
	 * 		several identities running in a given swirld)
	 * @param createKeys
	 * 		should key pairs and certs be created and added to the various key stores?
	 * @param keyStore
	 * 		if createKeys==false, then Crypto will read the 3 keyPairs
	 * 		(signing,agreement,encryption)
	 * 		from this key store. If createKeys==true, then this is ignored.
	 * @param signingTrustStore
	 * 		the trust store for all the sig certs (self-signed signing cert)
	 * @param agreementTrustStore
	 * 		the trust store for all the agr certs (agreement cert, signed by signing key)
	 * @param encryptionTrustStore
	 * 		the trust store for all the enc certs (encryption cert, signed by signing key)
	 * @param cryptoThreadPool
	 * 		the thread pool that will be used for all operations that can be done in parallel,
	 * 		like
	 * 		signing and verifying
	 */
	public Crypto(long selfId, String name, byte[] masterKey, byte[] swirldId,
			byte[] memberId, Boolean createKeys, KeyStore keyStore,
			KeyStore signingTrustStore, KeyStore encryptionTrustStore,
			KeyStore agreementTrustStore, ExecutorService cryptoThreadPool) {

		this.sigTrustStore = signingTrustStore;
		this.encTrustStore = encryptionTrustStore;
		this.agrTrustStore = agreementTrustStore;
		this.cryptoThreadPool = cryptoThreadPool;

		if (!createKeys) {
			try {
				char[] password = getKeystorePassword();
				sigCert = (X509Certificate) sigTrustStore
						.getCertificate("s-" + name);
				encCert = (X509Certificate) encTrustStore
						.getCertificate("e-" + name);
				agrCert = (X509Certificate) agrTrustStore
						.getCertificate("a-" + name);
				sigKeyPair = new KeyPair(
						keyStore.getCertificate("s-" + name).getPublicKey(),
						(PrivateKey) keyStore.getKey("s-" + name, password));
				encKeyPair = new KeyPair(
						keyStore.getCertificate("e-" + name).getPublicKey(),
						(PrivateKey) keyStore.getKey("e-" + name, password));
				agrKeyPair = new KeyPair(
						keyStore.getCertificate("a-" + name).getPublicKey(),
						(PrivateKey) keyStore.getKey("a-" + name, password));
			} catch (UnrecoverableKeyException | KeyStoreException
					| NoSuchAlgorithmException e) {
				log.error(EXCEPTION.getMarker(), "", e);
			}

			log.debug(CERTIFICATES.getMarker(), "Certificate !createKeys: {}",
					sigCert);
			log.debug(CERTIFICATES.getMarker(), "Certificate !createKeys: {}",
					encCert);
			log.debug(CERTIFICATES.getMarker(), "Certificate !createKeys: {}",
					agrCert);
			return;
		}

		// createKeys must be true if execution reaches this point

		KeyPairGenerator sigKeyGen = null;
		KeyPairGenerator encKeyGen = null;
		KeyPairGenerator agrKeyGen = null;

		SecureRandom sigDetRandom = null; // deterministic CSPRNG, used briefly then discarded
		SecureRandom encDetRandom = null; // deterministic CSPRNG, used briefly then discarded
		SecureRandom agrDetRandom = null; // deterministic CSPRNG, used briefly then discarded
		try {
			sigKeyGen = KeyPairGenerator.getInstance(SIG_TYPE1, SIG_PROVIDER);
			encKeyGen = KeyPairGenerator.getInstance(ENC_TYPE, ENC_PROVIDER);
			agrKeyGen = KeyPairGenerator.getInstance(AGR_TYPE, AGR_PROVIDER);

			sigDetRandom = getDetRandom(); // deterministic, not shared
			encDetRandom = getDetRandom(); // deterministic, not shared
			agrDetRandom = getDetRandom(); // deterministic, not shared
		} catch (NoSuchAlgorithmException | NoSuchProviderException e) {
			log.error(EXCEPTION.getMarker(), "", e);
			CommonUtils.tellUserConsolePopup("ERROR",
					"ERROR: This Java installation does not have the needed cryptography providers installed");
			return;
		}

		sigDetRandom.setSeed(masterKey);
		sigDetRandom.setSeed(swirldId);
		sigDetRandom.setSeed(memberId);
		sigDetRandom.setSeed(2);
		sigKeyGen.initialize(SIG_KEY_SIZE_BITS, sigDetRandom);

		encDetRandom.setSeed(masterKey);
		encDetRandom.setSeed(swirldId);
		encDetRandom.setSeed(memberId);
		encDetRandom.setSeed(1);
		encKeyGen.initialize(ENC_KEY_SIZE_BITS, encDetRandom);

		agrDetRandom.setSeed(masterKey);
		agrDetRandom.setSeed(swirldId);
		agrDetRandom.setSeed(memberId);
		agrDetRandom.setSeed(0);
		agrKeyGen.initialize(AGR_KEY_SIZE_BITS, agrDetRandom);

		sigKeyPair = sigKeyGen.generateKeyPair();
		encKeyPair = encKeyGen.generateKeyPair();
		agrKeyPair = agrKeyGen.generateKeyPair();

		try {
			String dnS, dnA, dnE;
			// dn= distinguishedName("Alice", "orgName",
			// new String[] { "orgUnitName" }, "streetAddress", "city",
			// "NY", "US", new String[] { "domain", "com" }, "A");
			dnS = distinguishedName("s-" + name, null, null, null, null, null,
					null, null, null);
			dnA = distinguishedName("a-" + name, null, null, null, null, null,
					null, null, null);
			dnE = distinguishedName("e-" + name, null, null, null, null, null,
					null, null, null);

			// create the 3 certs (java.security.cert.Certificate)
			// all 3 are signed by sigKeyPair, so sigCert is self-signed

			sigCert = generateCertificate(dnS, sigKeyPair, dnS, sigKeyPair,
					sigDetRandom, null, null);

			encCert = generateCertificate(dnE, encKeyPair, dnS, sigKeyPair,
					encDetRandom, null, null);

			agrCert = generateCertificate(dnA, agrKeyPair, dnS, sigKeyPair,
					agrDetRandom, null, null);

			log.debug(CERTIFICATES.getMarker(), "Certificate createKeys: {}",
					sigCert);
			log.debug(CERTIFICATES.getMarker(), "Certificate createKeys: {}",
					agrCert);
			log.debug(CERTIFICATES.getMarker(), "Certificate createKeys: {}",
					encCert);

			// add to the 3 trust stores (which have references stored here and in the caller)

			sigTrustStore.setCertificateEntry("s-" + name, sigCert);
			agrTrustStore.setCertificateEntry("a-" + name, agrCert);
			encTrustStore.setCertificateEntry("e-" + name, encCert);
		} catch (Exception /* GeneralSecurityException | IOException */ e) {
			log.error(EXCEPTION.getMarker(), "", e);
		}
	}

	/**
	 * Try to load the public.pfx and private-*.pfx key stores from disk. If successful, it will return an
	 * array containing the public.pfx followed by each private-*.pfx in the order that the names are given
	 * in the input. If public.pfx is missing, or even one of the private-*.pfx files is missing, or one of
	 * those files fails to load properly, then it returns null. It does NOT return a partial list with the
	 * ones that worked.
	 *
	 * @param path
	 * 		the key directory, such as /user/test/sdk/data/key/
	 * @param names
	 * 		list of the name of each member, from the address book
	 * @param cryptoThreadPool
	 * 		the thread pool that will be used to load the keys in parallel
	 * @return array of key stores
	 */
	static KeyStore[] loadKeys(File path, List<String> names,
			ExecutorService cryptoThreadPool) {
		char[] password = getKeystorePassword();
		KeyStore[] stores = new KeyStore[1 + names.size()];
		int missingCount = 0; // count of how many stores do not exist
		String missing = ""; // paths and filenames of all stores that have problems loading

		try {
			for (int i = 0; i < stores.length; i++) {
				stores[i] = KeyStore.getInstance("pkcs12");
			}
		} catch (KeyStoreException e) {
			log.error(EXCEPTION.getMarker(), "", e);
			return null;
		}
		List<Future<Object>> keyLoading = new ArrayList<>(stores.length);
		List<File> filenames = new ArrayList<>(stores.length);
		for (int i = 0; i < stores.length; i++) {
			final File filename;
			if (i == 0) {
				filename = CommonUtils.canonicalFile(path, "public.pfx");
			} else {
				filename = CommonUtils.canonicalFile(path,
						"private-" + names.get(i - 1) + ".pfx");
			}
			filenames.add(filename);
			if (!filename.exists()) {
				missingCount++;
				missing += "   " + filename + " \n";
				keyLoading.add(null);
			} else {
				final KeyStore store = stores[i];
				keyLoading.add(cryptoThreadPool.submit(() -> {
					FileInputStream fis = new FileInputStream(filename);
					store.load(fis, password);
					return null;
				}));
			}
		}
		for (int i = 0; i < stores.length; i++) {
			try {
				if (keyLoading.get(i) != null) {
					keyLoading.get(i).get();
					if (stores[i].size() == 0) {
						CommonUtils.tellUserConsolePopup("ERROR",
								"Error: there are no valid keys or certificates in "
										+ filenames.get(i));
						return null;
					}
				}
			} catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
				return null;
			} catch (KeyStoreException | ExecutionException ex) {
				CommonUtils.tellUserConsolePopup("ERROR",
						"Error: there was a problem reading "
								+ filenames.get(i));
				return null;
			}
		}
		if (missingCount == 0) {// all files loaded correctly, so use them
			CommonUtils.tellUserConsole(
					"Reading crypto keys from the files here:   " + path
							+ "*.pfx");
			return stores;
		}
		if (missingCount == stores.length) {// no key store files exist, so create our own keys
			CommonUtils.tellUserConsole(
					"Creating keys, because there are no files: " + path
							+ File.separator + "*.pfx");
			return null;
		}
		// it looks like some of the stores existed, and some didn't. So create our own keys.
		CommonUtils.tellUserConsolePopup("ERROR",
				"ERROR: creating all new keys because the following files are missing: \n"
						+ missing);
		return null;
	}

	/**
	 * ensure this can't be instantiated without a seed.
	 */
	@SuppressWarnings("unused")
	private Crypto() {

	}

	/**
	 * Returns the password to be used to protected the PKCS12 key store containing the nodes RSA key pairs. This method
	 * safely falls back on default values if no password was provided.
	 *
	 * @return the key store password
	 */
	private static char[] getKeystorePassword() {
		return (Settings.crypto.keystorePassword == null) ?
				CryptographySettings.DEFAULT_KEYSTORE_PASSWORD.toCharArray() :
				Settings.crypto.keystorePassword.toCharArray();
	}

	/**
	 * Create a new trust store that is initially empty, but will later have all the members' key agreement
	 * public key certificates added to it.
	 *
	 * @return the empty KeyStore to be used as a trust store for TLS for syncs.
	 */
	static KeyStore createEmptyTrustStore() {
		KeyStore trustStore = null;
		try {
			trustStore = KeyStore.getInstance(KEYSTORE_TYPE);
			trustStore.load(null);
		} catch (KeyStoreException | NoSuchAlgorithmException
				| CertificateException | IOException e) {
			log.error(EXCEPTION.getMarker(), "", e);
			return null;
		}
		return trustStore;
	}

	/**
	 * Digitally sign the data with the private key. Return null if anything goes wrong (e.g., bad private
	 * key).
	 * <p>
	 * The returned signature will be at most SIG_SIZE_BYTES bytes, which is 104 for the CNSA suite
	 * parameters.
	 *
	 * @param data
	 * 		the data to sign
	 * @return the signature (or null if any errors)
	 */
	public byte[] sign(byte[] data) {
		Signature signature = null;
		try {
			signature = Signature.getInstance(SIG_TYPE2, SIG_PROVIDER);
			signature.initSign(sigKeyPair.getPrivate());
			log.debug(EVENT_SIG.getMarker(),
					"event is being signed, publicKey={} privateKey={}",
					sigKeyPair.getPublic(),
					sigKeyPair.getPrivate().getEncoded());
			signature.update(data);
			final byte[] result = signature.sign();
			if (result == null) {
				log.error(EXCEPTION.getMarker(), "ERROR: signature is null");
			}
			return result;
		} catch (NoSuchAlgorithmException | NoSuchProviderException
				| InvalidKeyException | SignatureException e) {
			log.error(EXCEPTION.getMarker(), "ERROR in sig 3", e);
		}
		return null;
	}

	/**
	 * Digitally sign the data with the private key. Return null if anything goes wrong (e.g., bad private
	 * key).
	 * <p>
	 * The returned signature will be at most SIG_SIZE_BYTES bytes, which is 104 for the CNSA suite
	 * parameters.
	 *
	 * @param keys
	 * 		keypair to be used for signing
	 * @param data
	 * 		the data to sign
	 * @return the signature (or null if any errors)
	 */
	public static byte[] sign(final KeyPair keys, final byte[] data) {
		Signature signature = null;
		try {
			signature = Signature.getInstance(SIG_TYPE2, SIG_PROVIDER);
			signature.initSign(keys.getPrivate());
			log.debug(EVENT_SIG.getMarker(),
					"event is being signed, publicKey={} privateKey={}",
					keys.getPublic(),
					keys.getPrivate().getEncoded());
			signature.update(data);
			final byte[] result = signature.sign();
			if (result == null) {
				log.error(EXCEPTION.getMarker(), "ERROR: signature is null");
			}
			return result;
		} catch (NoSuchAlgorithmException | NoSuchProviderException
				| InvalidKeyException | SignatureException e) {
			log.error(EXCEPTION.getMarker(), "ERROR in sig 3", e);
		}
		return null;
	}

	/**
	 * Verify the given signature for the given data. This is submitted to the thread pool so that it will
	 * be done in parallel with other signature verifications and key generation operations. This method
	 * returns a Future immediately. If the signature is valid, then a get() method on that Future will
	 * eventually return a Boolean which is true if the signature was valid. After the thread does the
	 * validation, and before it returns, it will run doLast(true) if the signature was valid, or
	 * doLast(false) if it wasn't.
	 *
	 * This is flexible. It is OK to ignore the returned Future, and only have doLast handle the result. It
	 * is also OK to pass in (Boolean b) for doLast, and handle the result of doing a .get() on the
	 * Future. Or both mechanisms can be used.
	 *
	 * @param data
	 * 		the data that was signed
	 * @param signature
	 * 		the claimed signature of that data
	 * @param publicKey
	 * 		the claimed public key used to generate that signature
	 * @param doLast
	 * 		a function that will be run after verification, and will be passed true if the signature
	 * 		is valid. To do nothing, pass in (Boolean b)
	 * @return validObject if the signature is valid, else returns null
	 */
	public Future<Boolean> verifySignatureParallel(byte[] data, byte[] signature,
			PublicKey publicKey, Consumer<Boolean> doLast) {
		return cryptoThreadPool.submit(new Callable<Boolean>() {
			@Override
			public Boolean call() {
				boolean result = verifySignature(data, signature, publicKey);
				doLast.accept(result);
				return result;
			}
		});
	}

	/**
	 * check whether the given signature is valid
	 *
	 * @param data
	 * 		the data that was signed
	 * @param signature
	 * 		the claimed signature of that data
	 * @param publicKey
	 * 		the claimed public key used to generate that signature
	 * @return true if the signature is valid
	 */
	static boolean verifySignature(byte[] data, byte[] signature,
			PublicKey publicKey) {
		try {
			final Signature sig = Signature.getInstance(SIG_TYPE2, SIG_PROVIDER);
			log.debug(EVENT_SIG.getMarker(),
					"event is being verified, publicKey={}", publicKey);
			sig.initVerify(publicKey);
			sig.update(data);
			return sig.verify(signature);
		} catch (NoSuchAlgorithmException | NoSuchProviderException
				| InvalidKeyException | SignatureException e) {
			log.error(EXCEPTION.getMarker(), "", e);
		}
		return false;
	}

	/**
	 * Print to the console all the available security providers in this JRE/installation of Java.
	 */
	void printProviders() {
		try {
			for (Provider p : java.security.Security.getProviders()) {
				CommonUtils.tellUserConsole(p + " -- " + p.getInfo());
				for (Enumeration<?> e = p.keys(); e.hasMoreElements(); ) {
					CommonUtils.tellUserConsole("\t" + e.nextElement());
				}
			}
		} catch (Exception e) {
			CommonUtils.tellUserConsole(ExceptionUtils.getStackTrace(e));
		}
	}

	/**
	 * return a key-value pair as is found in a distinguished name in a n x509 certificate. For example
	 * "CN=Alice" or ",CN=Alice" (if it isn't the first). This returned value (without the comma) is called
	 * a "relative distinguished name" in RFC4514. If the value is null or "", then it returns "".
	 * Otherwise, it sets separator[0] to "," and returns the RDN.
	 *
	 * @param commaSeparator
	 * 		should initially be "" then "," for all calls thereafter
	 * @param attributeType
	 * 		the code, such as CN or STREET
	 * @param attributeValue
	 * 		the value, such as "John Smith"
	 * @return the RDN (if any), possibly preceded by a comma (if not first)
	 */
	private static String rdn(String[] commaSeparator, String attributeType,
			String attributeValue) {
		if (attributeValue == null || attributeValue.equals("")) {
			return "";
		}
		// need to escape the 6 characters: \ " , ; < >
		// and spaces at start/end of string
		// and # at start of string.
		// The RFC requires + to be escaped if it doesn't combine two separate values,
		// but that escape must be done by the caller. It won't be done here.
		attributeValue = attributeValue.replaceAll("\\\\", "\\\\");
		attributeValue = attributeValue.replaceAll("\"", "\\\"");
		attributeValue = attributeValue.replaceAll(",", "\\,");
		attributeValue = attributeValue.replaceAll(";", "\\;");
		attributeValue = attributeValue.replaceAll("<", "\\<");
		attributeValue = attributeValue.replaceAll(">", "\\>");
		attributeValue = attributeValue.replaceAll(" $", "\\ ");
		attributeValue = attributeValue.replaceAll("^ ", "\\ ");
		attributeValue = attributeValue.replaceAll("^#", "\\#");
		String s = commaSeparator[0] + attributeType + "=" + attributeValue;
		commaSeparator[0] = ",";
		return s;
	}

	/**
	 * Return the distinguished name for an entity for use in an x509 certificate, such as "CN=Alice+Bob,
	 * L=Los Angeles, ST=CA, C=US". Any component that is either null or the empty string will be left out.
	 * If there are multiple answers for a field, separate them with plus signs, such as "Alice+Bob" for
	 * both Alice and Bob. For the organization, the list of names should go from the top level to the
	 * bottom (most general to least). For the domain, it should go from general to specific, such as
	 * {"com", "acme","www"}.
	 * <p>
	 * This method will take care of escaping values, so it is ok to pass in a common name such as "#John
	 * Smith, Jr. ", which is automatically converted to "\#John Smith\, Jr\.\ ", which follows the rules in
	 * the RFC, such as escaping the space at the end but not the one in the middle.
	 * <p>
	 * The only exception is the plus sign. If the string "Alice+Bob" is passed in for the common name, that
	 * is interpreted as two names, "Alice" and "Bob". If there is a single person named "Alice+Bob", then
	 * it must be escaped by passing in the string "Alice\+Bob", which would be typed as a Java literal as
	 * "Alice\\+Bob".
	 * <p>
	 * This follows RFC 4514, which gives these distinguished name string representations:
	 *
	 * <pre>
	 * String  X.500 AttributeType
	 * ------  --------------------------------------------
	 * CN      commonName (2.5.4.3)
	 * L       localityName (2.5.4.7)
	 * ST      stateOrProvinceName (2.5.4.8)
	 * O       organizationName (2.5.4.10)
	 * OU      organizationalUnitName (2.5.4.11)
	 * C       countryName (2.5.4.6)
	 * STREET  streetAddress (2.5.4.9)
	 * DC      domainComponent (0.9.2342.19200300.100.1.25)
	 * UID     userId (0.9.2342.19200300.100.1.1)
	 * </pre>
	 *
	 * @param commonName
	 * 		name such as "John Smith" or "Acme Inc"
	 * @param orgName
	 * 		organization name, such as "Acme"
	 * @param orgUnitName
	 * 		organization unit name. To represent a subunit within a larger unit within a larger unit,
	 * 		go from largest to smallest, such as { "engineering", "software", "project zeta" }
	 * @param streetAddress
	 * 		first line of address, such as "123 Oak Drive Suite 45"
	 * @param city
	 * 		city, such as "Los Angeles"
	 * @param state
	 * 		state or province, such as "New York" or "NY"
	 * @param country
	 * 		country, 2-letter code, such as "US"
	 * @param domain
	 * 		domain components in reverse order, such as {"com", "acme", "www"}
	 * @param id
	 * 		the user ID, such as "jsmith". For Swirlds, use the memberID, such as "12"
	 * @return the distinguished name, suitable for passing to generateCertificate()
	 */
	static String distinguishedName(String commonName, String orgName,
			String[] orgUnitName, String streetAddress, String city,
			String state, String country, String[] domain, String id) {
		String name = "";
		String[] commaSeparator = new String[] { "" };
		name += rdn(commaSeparator, "CN", commonName);
		name += rdn(commaSeparator, "O", orgName);
		if (orgUnitName != null) {
			for (String unit : orgUnitName) {
				name += rdn(commaSeparator, "OU", unit);

			}
		}
		name += rdn(commaSeparator, "STREET", streetAddress);
		name += rdn(commaSeparator, "L", city);
		name += rdn(commaSeparator, "ST", state);
		name += rdn(commaSeparator, "C", country);
		if (domain != null) {
			for (String d : domain) {
				name += rdn(commaSeparator, "DC", d);

			}
		}
		name += rdn(commaSeparator, "UID", id);
		return name;
	}

	/**
	 * Create a signed X.509 Certificate. The distinguishedName parameter can be generated by calling
	 * distinguishedName(). In the distinguished name, the UID should be the memberId used in the
	 * AddressBook here. The certificate only contains the public key from the given key pair, though it
	 * uses the private key during the self signature.
	 * <p>
	 * The certificate records that pair.publicKey is owned by distinguishedName. This certificate is signed
	 * by a Certificate Authority (CA), whose name is CaDistinguishedName and whose key pair is CaPair.
	 * <p>
	 * In Swirlds, each member creates a separate certificate for each of their 3 key pairs (signing,
	 * agreement, encryption). The signing certificate is self-signed, and is treated as if it were a CA.
	 * The other two certificates are each signed by the signing key pair. So for either of them, the
	 * complete certificate chain consists of two certificates.
	 * <p>
	 * For the validity dates, if null is passed in, then it starts in 2000 and goes to 2100. Another
	 * alternative is to pass in (new Date()) for the start, and new Date(from.getTime() + 365 * 86400000l)
	 * for the end to make it valid from now for the next 365 days.
	 *
	 * @param distinguishedName
	 * 		the X.509 Distinguished Name, such as is returned by distName()
	 * @param pair
	 * 		the KeyPair whose public key is to be listed as belonging to distinguishedName
	 * @param caDistinguishedName
	 * 		the name of the CA (which in Swirlds is always the same as distinguishedName)
	 * @param caPair
	 * 		the KeyPair of the CA (which in Swirlds is always the signing key pair)
	 * @param secureRandom
	 * 		the random number generator used to generate the certificate
	 * @param validFrom
	 * 		start of validity period (null means 1 Jan 2000)
	 * @param validTo
	 * 		end of validity period (null means 1 Jan 2100)
	 * @return the self-signed certificate
	 * @throws OperatorCreationException
	 * @throws CertificateException
	 */

	static X509Certificate generateCertificate(String distinguishedName,
			KeyPair pair, String caDistinguishedName, KeyPair caPair,
			SecureRandom secureRandom, Date validFrom, Date validTo)
			throws OperatorCreationException, CertificateException {

		validFrom = (validFrom != null) ? validFrom : DEFAULT_VALID_FROM;
		validTo = (validTo != null) ? validTo : DEFAULT_VALID_TO;

		X509v3CertificateBuilder v3CertBldr = new JcaX509v3CertificateBuilder(
				new X500Principal(caDistinguishedName), // issuer
				new BigInteger(64, secureRandom), // serial number
				validFrom, // start time
				validTo, // expiry time
				new X500Principal(distinguishedName), // subject
				pair.getPublic()); // subject public key

		JcaContentSignerBuilder signerBuilder = new JcaContentSignerBuilder(
				SIG_TYPE2).setProvider(BouncyCastleProvider.PROVIDER_NAME);
		X509Certificate cert = new JcaX509CertificateConverter()
				.setProvider(BouncyCastleProvider.PROVIDER_NAME)
				.getCertificate(v3CertBldr
						.build(signerBuilder.build(caPair.getPrivate())));
		return cert;
	}

}

